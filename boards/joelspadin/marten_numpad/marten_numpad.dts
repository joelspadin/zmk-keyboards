/dts-v1/;

#include <nordic/nrf52840_qiaa.dtsi>
#include <common/nordic/nrf52840_uf2_boot_mode.dtsi>
#include <layouts/common/numpad/21_key.dtsi>
#include <layouts/common/numpad/22_key_00.dtsi>
#include <dt-bindings/zmk/hid_indicators.h>
#include <dt-bindings/zmk/matrix_transform.h>

#include "marten_numpad-pinctrl.dtsi"

&layout_numpad_21_key {
    kscan = <&kscan>;
    transform = <&transform_numpad_21>;
};

&layout_numpad_22_key_00 {
    kscan = <&kscan>;
    transform = <&transform_numpad_22>;
};

/ {
    model = "Marten Numpad";
    compatible = "marten_numpad";

    chosen {
        zephyr,code-partition = &code_partition;
        zephyr,sram = &sram0;
        zephyr,flash = &flash0;
        zmk,battery = &npm1300_fuel_gauge;
        // zmk,battery = &vbatt;
        zmk,charger = &npm1300_charger_wrapper;
        zmk,physical-layout = &layout_numpad_21_key;
    };

    leds {
        compatible = "gpio-leds";

        numlock_led: numlock_led {
            gpios = <&gpio0 31 GPIO_ACTIVE_HIGH>;
        };
    };

    pwm_leds {
        compatible = "pwm-leds";

        status_led: status_led {
            pwms = <&pwm0 0 PWM_USEC(20) PWM_POLARITY_NORMAL>;
        };

        // Numlock LED can be switched to PWM with the following, but that results
        // in ~400 uA extra power drain, even when just using 100% brightness.
        // numlock_led: numlock_led {
        //     pwms = <&pwm0 1 PWM_MSEC(20) PWM_POLARITY_NORMAL>;
        // };
        // Also need to add "NRF_PSEL(PWM_OUT1, 0, 31)" to &pwm0_default and &pwm0_sleep.
    };

    indicators {
        compatible = "zmk,indicator-leds";

        numlock_indicator: numlock {
            leds = <&numlock_led>;
            indicator = <HID_INDICATOR_NUM_LOCK>;

            // Num lock will mostly be on, so to save battery life, only light
            // the LED when it is *off*.
            active-brightness = <0>;
            inactive-brightness = <100>;
        };
    };

    kscan: kscan {
        compatible = "zmk,kscan-composite";
        rows = <6>;
        columns = <4>;

        matrix {
            kscan = <&kscan_matrix>;
        };

        left_encoder {
            kscan = <&kscan_left_encoder>;
            // Overlay onto the top-left matrix position
            row-offset = <0>;
            col-offset = <0>;
        };

        right_encoder {
            kscan = <&kscan_right_encoder>;
            // Overlay onto the top-right matrix position
            row-offset = <0>;
            col-offset = <4>;
        };
    };

    kscan_matrix: kscan_matrix {
        compatible = "zmk,kscan-gpio-matrix";
        diode-direction = "col2row";
        wakeup-source;

        col-gpios
        = <&gpio1 14 GPIO_ACTIVE_HIGH>
        , <&gpio1 12 GPIO_ACTIVE_HIGH>
        , <&gpio0 15 GPIO_ACTIVE_HIGH>
        , <&gpio0 10 GPIO_ACTIVE_HIGH>
        ;

        row-gpios
        = <&gpio0 13 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>
        , <&gpio0 3 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>
        , <&gpio0 28 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>
        , <&gpio0 2 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>
        , <&gpio0 29 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>
        , <&gpio0 25 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>
        ;
    };

    kscan_left_encoder: kscan_left_encoder {
        compatible = "zmk,kscan-gpio-direct";
        wakeup-source;

        input-gpios = <&gpio0 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
    };

    kscan_right_encoder: kscan_right_encoder {
        compatible = "zmk,kscan-gpio-direct";
        wakeup-source;

        input-gpios = <&gpio0 17 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
    };

    transform_numpad_21: transform_numpad_21 {
        compatible = "zmk,matrix-transform";
        columns = <4>;
        rows = <6>;
        map = <
        RC(0,0) RC(0,1) RC(0,2) RC(0,3)
        RC(1,0) RC(1,1) RC(1,2) RC(1,3)
        RC(2,0) RC(2,1) RC(2,2) RC(3,3)
        RC(3,0) RC(3,1) RC(3,2)
        RC(4,0) RC(4,1) RC(4,2) RC(5,3)
        RC(5,0)         RC(5,2)
        >;
    };

    transform_numpad_22: transform_numpad_22 {
        compatible = "zmk,matrix-transform";
        columns = <4>;
        rows = <6>;
        map = <
        RC(0,0) RC(0,1) RC(0,2) RC(0,3)
        RC(1,0) RC(1,1) RC(1,2) RC(1,3)
        RC(2,0) RC(2,1) RC(2,2) RC(3,3)
        RC(3,0) RC(3,1) RC(3,2)
        RC(4,0) RC(4,1) RC(4,2) RC(5,3)
        RC(5,0) RC(5,1) RC(5,2)
        >;
    };

    // TODO: use the NRF QDEC driver for one of these? If so, which one?
    left_encoder: left_encoder {
        compatible = "alps,ec11";
        status = "disabled";
        a-gpios = <&gpio0 12 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
        b-gpios = <&gpio0 16 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
        steps = <60>;
    };

    right_encoder: right_encoder {
        compatible = "alps,ec11";
        status = "disabled";
        a-gpios = <&gpio0 21 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
        b-gpios = <&gpio0 19 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
        steps = <60>;
    };

    // TODO: disable this and use npm1300 fuel gauge instead
    vbatt: vbatt {
        compatible = "zmk,battery-nrf-vddh";
    };
};

// Enable DC-DC converter on high voltage regulator
&reg0 {
    status = "okay";
};

// Enable DC-DC converter on internal regulator
&reg1 {
    regulator-initial-mode = <NRF5X_REG_MODE_DCDC>;
};

&adc {
    status = "okay";
};

&gpiote {
    status = "okay";
};

&gpio0 {
    status = "okay";
};

&gpio1 {
    status = "okay";
};

&uicr {
    nfct-pins-as-gpios;
};

&pwm0 {
    status = "okay";
    pinctrl-0 = <&pwm0_default>;
    pinctrl-1 = <&pwm0_sleep>;
    pinctrl-names = "default", "sleep";
};

&i2c0 {
    compatible = "nordic,nrf-twi";
    status = "okay";

    pinctrl-0 = <&i2c0_default>;
    pinctrl-1 = <&i2c0_sleep>;
    pinctrl-names = "default", "sleep";

    npm1300_pmic: pmic@6b {
        compatible = "nordic,npm1300";
        reg = <0x6b>;

        host-int-gpios = <&gpio0 30 0>;
        pmic-int-pin = <1>;
        long-press-reset = "one-button";
        ship-to-active-time-ms = <96>;

        npm1300_regulators: regulators {
            compatible = "nordic,npm1300-regulator";

            main_regulator: BUCK2 {
                regulator-init-microvolt = <3300000>;
                regulator-min-microvolt = <3300000>;
                regulator-max-microvolt = <3300000>;
                regulator-always-on;
            };
        };

        npm1300_charger: charger {
            compatible = "nordic,npm1300-charger";
            charging-enable;

            term-microvolt = <4150000>;
            term-warm-microvolt = <4000000>;
            current-microamp = <250000>;
            dischg-limit-microamp = <200000>;
            vbus-limit-microamp = <500000>;

            // No thermistor
            thermistor-ohms = <0>;
            thermistor-beta = <3380>;
        };

        npm1300_leds: leds {
            compatible = "nordic,npm1300-led";
            nordic,led0-mode = "charging";
            nordic,led1-mode = "host";
            nordic,led2-mode = "host";
        };

        npm1300_charger_wrapper: charger_wrapper {
            compatible = "nordic,npm1300-charger-new-api";

            charger = <&npm1300_charger>;
        };

        npm1300_fuel_gauge: fuel_gauge {
            compatible = "nordic,npm1300-fuel-gauge";

            charger = <&npm1300_charger>;
        };
    };
};

marten_i2c: &i2c1 {
    compatible = "nordic,nrf-twim";
    status = "disabled";

    pinctrl-0 = <&i2c1_default>;
    pinctrl-1 = <&i2c1_sleep>;
    pinctrl-names = "default", "sleep";
};

marten_spi: &spi1 {
    compatible = "nordic,nrf-spim";
    status = "disabled";

    pinctrl-0 = <&spi1_default>;
    pinctrl-1 = <&spi1_sleep>;
    pinctrl-names = "default", "sleep";
    cs-gpios = <&gpio1 8 GPIO_ACTIVE_HIGH>;
};

zephyr_udc0: &usbd {
    status = "okay";
};

&flash0 {
    partitions {
        compatible = "fixed-partitions";
        #address-cells = <1>;
        #size-cells = <1>;

        code_partition: partition@1000 {
            reg = <DT_SIZE_K(4) DT_SIZE_K(844)>;
        };

        // The flash starting at 0x000d4000 and ending at
        // 0x000f3fff is reserved for use by the application.

        storage_partition: partition@d4000 {
            reg = <DT_SIZE_K(848) DT_SIZE_K(128)>;
        };

        boot_partition: partition@f4000 {
            reg = <DT_SIZE_K(976) DT_SIZE_K(48)>;
        };
    };
};
